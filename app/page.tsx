"use client";

import { useEffect, useState, useCallback } from "react";
import { sdk } from "@farcaster/miniapp-sdk";
import { useAccount } from "wagmi";
import { HeroSection } from "@/components/HeroSection";
import { RegenerateButton } from "@/components/RegenerateButton";
import { MintButton } from "@/components/MintButton";
import { SuccessModal } from "@/components/SuccessModal";
import { TopSection } from "@/components/TopSection";
import { SplashScreen } from "@/components/SplashScreen";
import { useWarplets } from "@/hooks/useWarplets";
import { useGenerationStorage } from "@/hooks/useGenerationStorage";
import { useSplashTransition } from "@/hooks/useSplashTransition";
import { shareToFarcaster, checkFidMinted } from "@/lib/generators";
import { GEOPLET_CONFIG } from "@/lib/contracts";
import { toast } from "sonner";

export default function Home() {
  const [generatedImage, setGeneratedImage] = useState<string | null>(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false);
  const [isMinted, setIsMinted] = useState(false);
  const [showSuccessModal, setShowSuccessModal] = useState(false);
  const [mintTxHash, setMintTxHash] = useState<string | null>(null);
  const [mintedTokenId, setMintedTokenId] = useState<string | null>(null);
  const [serviceError, setServiceError] = useState<string | null>(null);
  const [isPageLoading, setIsPageLoading] = useState(true);

  const { address } = useAccount();
  const { nft, fid } = useWarplets();
  const {
    saveGeneration,
    loadGeneration,
    deleteGeneration,
    isLoading: isLoadingStorage,
  } = useGenerationStorage();

  // Initialize Farcaster SDK
  useEffect(() => {
    sdk.actions.ready().catch(console.error);
  }, []);

  // Load saved generation on mount (if exists)
  useEffect(() => {
    if (!fid || !address) return;

    const loadSavedGeneration = async () => {
      // Check if FID is already minted
      const fidIsMinted = await checkFidMinted(fid.toString());

      if (fidIsMinted) {
        // FID is minted - fetch from Alchemy instead of Supabase
        console.log("[LOAD-GEN] FID minted, fetching from Alchemy...");
        setIsMinted(true);

        try {
          const baseUrl = `https://base-mainnet.g.alchemy.com/nft/v3/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}/getNFTsForOwner`;
          const params = new URLSearchParams({
            owner: address,
            'contractAddresses[]': GEOPLET_CONFIG.address,
            withMetadata: 'true',
          });

          const response = await fetch(`${baseUrl}?${params}`);
          const data = await response.json();

          if (data.ownedNfts && data.ownedNfts.length > 0) {
            const mintedNFT = data.ownedNfts[0];
            const mintedImage =
              mintedNFT.image?.cachedUrl ||
              mintedNFT.image?.originalUrl ||
              mintedNFT.raw?.metadata?.image;

            if (mintedImage) {
              setGeneratedImage(mintedImage);
              setHasAutoGenerated(true);
              console.log("[LOAD-GEN] Loaded minted Geoplet from Alchemy");
            }
          } else {
            console.log("[LOAD-GEN] FID minted but NFT not owned (transferred)");
            setHasAutoGenerated(true); // Prevent auto-generation
          }
        } catch (error) {
          console.error("[LOAD-GEN] Failed to fetch from Alchemy:", error);
        }
      } else {
        // FID not minted - load from Supabase if available
        setIsMinted(false);
        const savedImage = await loadGeneration(fid);
        if (savedImage) {
          setGeneratedImage(savedImage);
          setHasAutoGenerated(true);
          console.log("[LOAD-GEN] Loaded saved generation from Supabase");
        }
      }
    };

    loadSavedGeneration();
  }, [fid, address, loadGeneration]);

  // Control page loading state - hide splash when critical data is ready
  useEffect(() => {
    // Show splash until we have all critical data
    const hasWallet = !!address;
    const hasWarpletData = !!nft && !!fid;
    const storageCheckComplete = !isLoadingStorage;

    if (hasWallet && hasWarpletData && storageCheckComplete) {
      // Small delay for smooth transition
      const timer = setTimeout(() => {
        setIsPageLoading(false);
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [address, nft, fid, isLoadingStorage]);

  // Trigger GSAP transition when loading completes
  useSplashTransition(isPageLoading);

  // Auto-generate after wallet connection and Warplet data loads
  useEffect(() => {
    if (!address || !nft || !fid || hasAutoGenerated || isGenerating) return;

    const autoGenerate = async () => {
      setIsGenerating(true);
      try {
        // Check if FID is already minted
        console.log("[AUTO-GEN] Checking if FID is already minted...");
        const fidIsMinted = await checkFidMinted(fid.toString());

        if (fidIsMinted) {
          // FID already minted - fetch and display the minted Geoplet from Alchemy
          console.log("[AUTO-GEN] FID already minted, fetching minted Geoplet from Alchemy...");
          setIsMinted(true);

          try {
            const baseUrl = `https://base-mainnet.g.alchemy.com/nft/v3/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}/getNFTsForOwner`;
            const params = new URLSearchParams({
              owner: address,
              'contractAddresses[]': GEOPLET_CONFIG.address,
              withMetadata: 'true',
            });

            const response = await fetch(`${baseUrl}?${params}`);
            const data = await response.json();

            if (data.ownedNfts && data.ownedNfts.length > 0) {
              // Get the minted Geoplet NFT
              const mintedNFT = data.ownedNfts[0];
              const mintedImage =
                mintedNFT.image?.cachedUrl ||
                mintedNFT.image?.originalUrl ||
                mintedNFT.raw?.metadata?.image;

              if (mintedImage) {
                setGeneratedImage(mintedImage);
                toast.success("Displaying your minted Geoplet!");
                console.log("[AUTO-GEN] Minted Geoplet displayed successfully");
              } else {
                console.warn("[AUTO-GEN] Minted NFT found but no image available");
                toast.error("Minted NFT found but no image available");
              }
            } else {
              // FID is minted but user doesn't own the NFT (transferred)
              console.log("[AUTO-GEN] FID minted but NFT not owned by current wallet (transferred)");
              toast.info("You already minted with this FID");
            }
          } catch (alchemyError) {
            console.error("[AUTO-GEN] Failed to fetch minted Geoplet from Alchemy:", alchemyError);
            toast.error("Failed to fetch minted Geoplet");
          }

          setHasAutoGenerated(true);
          setIsGenerating(false);
          return; // Exit early - don't generate
        }

        // FID not minted - continue with normal auto-generation
        console.log("[AUTO-GEN] FID not minted, proceeding with auto-generation...");
        setIsMinted(false);

        // Pre-check OpenAI availability
        console.log("[AUTO-GEN] Step 0: Checking OpenAI availability...");
        const precheckResponse = await fetch("/api/openai-precheck", {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        });

        const precheckData = await precheckResponse.json();

        if (!precheckResponse.ok || !precheckData.available) {
          throw new Error(precheckData.reason || "OpenAI service temporarily unavailable");
        }

        console.log("[AUTO-GEN] âœ… OpenAI service available");

        // Call generation API
        const response = await fetch("/api/generate-image", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            imageUrl: nft.thumbnailUrl || nft.imageUrl,
            tokenId: nft.tokenId,
            name: `Warplet #${nft.tokenId}`,
            fid: fid.toString(), // Add FID for free generation check
          }),
        });

        const data = await response.json();

        if (!data.success || !data.imageData) {
          throw new Error(data.error || "Generation failed");
        }

        // Save to Supabase
        const saved = await saveGeneration(fid, data.imageData);
        if (!saved) {
          console.warn("Failed to save generation to Supabase");
        }

        // Update state
        setGeneratedImage(data.imageData);
        setHasAutoGenerated(true);
        console.log("[AUTO-GEN] Auto-generation completed successfully");
      } catch (error) {
        console.error("Auto-generation failed:", error);

        const errorMessage = error instanceof Error ? error.message : "Unknown error";

        // Set friendly error message based on failure reason
        let friendlyError = "ðŸ˜… Auto-gen unavailable. Try Regenerate or refresh!";

        if (errorMessage.toLowerCase().includes("openai") || errorMessage.toLowerCase().includes("service")) {
          if (errorMessage.toLowerCase().includes("credit")) {
            friendlyError = "ðŸ”§ Our AI is refueling. Use Regenerate ($3) to skip the wait!";
          } else if (errorMessage.toLowerCase().includes("rate")) {
            friendlyError = "âš¡ Engine warming up. Try Regenerate or wait a moment!";
          } else {
            friendlyError = "ðŸŽ¨ Our AI artist is taking a break. Use Regenerate ($3) or refresh!";
          }
        }

        setServiceError(friendlyError);
        setHasAutoGenerated(true); // Prevent auto-retry loop
        toast.error(friendlyError, { duration: 8000 });
      } finally {
        setIsGenerating(false);
      }
    };

    // Small delay to show Warplet first
    const timer = setTimeout(() => {
      autoGenerate();
    }, 5000);

    return () => clearTimeout(timer);
  }, [address, nft, fid, hasAutoGenerated, isGenerating, saveGeneration]);

  // Share handlers
  const handleFarcasterShare = async () => {
    if (!generatedImage || !nft) return;
    try {
      await shareToFarcaster(generatedImage, nft.tokenId, nft.name);
    } catch (error) {
      console.error("Failed to share:", error);
      toast.error("Failed to share to Farcaster");
    }
  };

  const handleXShare = () => {
    const text = "Check out my Geoplet! ðŸŽ¨";
    const url = `https://geoplet.geoart.studio`;
    const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(
      text
    )}&url=${encodeURIComponent(url)}`;
    window.open(twitterUrl, "_blank");
  };

  return (
    <>
      {/* Splash Screen */}
      {isPageLoading && <SplashScreen />}

      {/* Main Content */}
      <div id="main-content" style={{ opacity: isPageLoading ? 0 : 1 }}>
        {/* Top Section */}
        <TopSection
          onFarcasterShare={generatedImage ? handleFarcasterShare : undefined}
          onXShare={generatedImage ? handleXShare : undefined}
        />

        {/* Service Error Banner */}
      {serviceError && (
        <div className="mx-auto max-w-2xl px-4 py-3 mb-4">
          <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded-r-lg flex items-start justify-between gap-3">
            <p className="text-sm text-yellow-800 flex-1">
              {serviceError}
            </p>
            <button
              onClick={() => setServiceError(null)}
              className="text-yellow-600 hover:text-yellow-800 transition-colors"
              aria-label="Dismiss error"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>
      )}

      {/* Main Content */}
      <main className="flex-1 flex flex-col gap-8 px-4 pb-20">
        {/* Hero Section */}
        <div className="mt-4">
          <HeroSection
            warpletImage={nft?.thumbnailUrl || nft?.imageUrl || null}
            warpletTokenId={nft?.tokenId || null}
            generatedImage={generatedImage}
            isGenerating={isGenerating}
            isMinted={isMinted}
          />
        </div>

        {/* Split Buttons: Regenerate & Mint */}
        <div className="flex flex-col gap-4 justify-center items-center">
          <RegenerateButton
            disabled={isGenerating}
            onRegenerate={(imageData) => {
              setGeneratedImage(imageData);
              setServiceError(null); // Clear error on successful regeneration
            }}
            onSaveToSupabase={async (imageData) => {
              if (!fid) return false;
              return await saveGeneration(fid, imageData);
            }}
          />
          <MintButton
            disabled={!generatedImage}
            generatedImage={generatedImage}
            onSuccess={(hash, tokenId) => {
              setMintTxHash(hash);
              setMintedTokenId(tokenId);
              setShowSuccessModal(true);
            }}
            onDeleteFromSupabase={async () => {
              if (!fid) return false;
              return await deleteGeneration(fid);
            }}
          />
        </div>
      </main>

      {/* Success Modal */}
      <SuccessModal
        isOpen={showSuccessModal}
        onClose={() => {
          setShowSuccessModal(false);
          setGeneratedImage(null);
        }}
        image={generatedImage}
        txHash={mintTxHash}
        tokenId={mintedTokenId}
      />
      </div>
    </>
  );
}
