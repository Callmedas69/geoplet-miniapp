"use client";

import { useEffect, useState, useCallback } from "react";
import { sdk } from "@farcaster/miniapp-sdk";
import { useAccount } from "wagmi";
import { HeroSection } from "@/components/HeroSection";
import { RegenerateButton } from "@/components/RegenerateButton";
import { MintButton } from "@/components/MintButton";
import { SuccessModal } from "@/components/SuccessModal";
import { TopSection } from "@/components/TopSection";
import { useWarplets } from "@/hooks/useWarplets";
import { useGenerationStorage } from "@/hooks/useGenerationStorage";
import { shareToFarcaster, checkFidMinted } from "@/lib/generators";
import { GEOPLET_CONFIG } from "@/lib/contracts";
import { toast } from "sonner";

export default function Home() {
  const [generatedImage, setGeneratedImage] = useState<string | null>(null);
  const [isGenerating, setIsGenerating] = useState(false);
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false);
  const [isMinted, setIsMinted] = useState(false);
  const [showSuccessModal, setShowSuccessModal] = useState(false);
  const [mintTxHash, setMintTxHash] = useState<string | null>(null);
  const [mintedTokenId, setMintedTokenId] = useState<string | null>(null);

  const { address } = useAccount();
  const { nft, fid } = useWarplets();
  const {
    saveGeneration,
    loadGeneration,
    deleteGeneration,
    isLoading: isLoadingStorage,
  } = useGenerationStorage();

  // Initialize Farcaster SDK
  useEffect(() => {
    sdk.actions.ready().catch(console.error);
  }, []);

  // Load saved generation on mount (if exists)
  useEffect(() => {
    if (!fid || !address) return;

    const loadSavedGeneration = async () => {
      // Check if FID is already minted
      const fidIsMinted = await checkFidMinted(fid.toString());

      if (fidIsMinted) {
        // FID is minted - fetch from Alchemy instead of Supabase
        console.log("[LOAD-GEN] FID minted, fetching from Alchemy...");
        setIsMinted(true);

        try {
          const baseUrl = `https://base-mainnet.g.alchemy.com/nft/v3/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}/getNFTsForOwner`;
          const params = new URLSearchParams({
            owner: address,
            'contractAddresses[]': GEOPLET_CONFIG.address,
            withMetadata: 'true',
          });

          const response = await fetch(`${baseUrl}?${params}`);
          const data = await response.json();

          if (data.ownedNfts && data.ownedNfts.length > 0) {
            const mintedNFT = data.ownedNfts[0];
            const mintedImage =
              mintedNFT.image?.cachedUrl ||
              mintedNFT.image?.originalUrl ||
              mintedNFT.raw?.metadata?.image;

            if (mintedImage) {
              setGeneratedImage(mintedImage);
              setHasAutoGenerated(true);
              console.log("[LOAD-GEN] Loaded minted Geoplet from Alchemy");
            }
          } else {
            console.log("[LOAD-GEN] FID minted but NFT not owned (transferred)");
            setHasAutoGenerated(true); // Prevent auto-generation
          }
        } catch (error) {
          console.error("[LOAD-GEN] Failed to fetch from Alchemy:", error);
        }
      } else {
        // FID not minted - load from Supabase if available
        setIsMinted(false);
        const savedImage = await loadGeneration(fid);
        if (savedImage) {
          setGeneratedImage(savedImage);
          setHasAutoGenerated(true);
          console.log("[LOAD-GEN] Loaded saved generation from Supabase");
        }
      }
    };

    loadSavedGeneration();
  }, [fid, address, loadGeneration]);

  // Auto-generate after wallet connection and Warplet data loads
  useEffect(() => {
    if (!address || !nft || !fid || hasAutoGenerated || isGenerating) return;

    const autoGenerate = async () => {
      setIsGenerating(true);
      try {
        // Check if FID is already minted
        console.log("[AUTO-GEN] Checking if FID is already minted...");
        const fidIsMinted = await checkFidMinted(fid.toString());

        if (fidIsMinted) {
          // FID already minted - fetch and display the minted Geoplet from Alchemy
          console.log("[AUTO-GEN] FID already minted, fetching minted Geoplet from Alchemy...");
          setIsMinted(true);

          try {
            const baseUrl = `https://base-mainnet.g.alchemy.com/nft/v3/${process.env.NEXT_PUBLIC_ALCHEMY_API_KEY}/getNFTsForOwner`;
            const params = new URLSearchParams({
              owner: address,
              'contractAddresses[]': GEOPLET_CONFIG.address,
              withMetadata: 'true',
            });

            const response = await fetch(`${baseUrl}?${params}`);
            const data = await response.json();

            if (data.ownedNfts && data.ownedNfts.length > 0) {
              // Get the minted Geoplet NFT
              const mintedNFT = data.ownedNfts[0];
              const mintedImage =
                mintedNFT.image?.cachedUrl ||
                mintedNFT.image?.originalUrl ||
                mintedNFT.raw?.metadata?.image;

              if (mintedImage) {
                setGeneratedImage(mintedImage);
                toast.success("Displaying your minted Geoplet!");
                console.log("[AUTO-GEN] Minted Geoplet displayed successfully");
              } else {
                console.warn("[AUTO-GEN] Minted NFT found but no image available");
                toast.error("Minted NFT found but no image available");
              }
            } else {
              // FID is minted but user doesn't own the NFT (transferred)
              console.log("[AUTO-GEN] FID minted but NFT not owned by current wallet (transferred)");
              toast.info("You already minted with this FID");
            }
          } catch (alchemyError) {
            console.error("[AUTO-GEN] Failed to fetch minted Geoplet from Alchemy:", alchemyError);
            toast.error("Failed to fetch minted Geoplet");
          }

          setHasAutoGenerated(true);
          setIsGenerating(false);
          return; // Exit early - don't generate
        }

        // FID not minted - continue with normal auto-generation
        console.log("[AUTO-GEN] FID not minted, proceeding with auto-generation...");
        setIsMinted(false);

        // Pre-check OpenAI availability
        console.log("[AUTO-GEN] Step 0: Checking OpenAI availability...");
        const precheckResponse = await fetch("/api/openai-precheck", {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        });

        const precheckData = await precheckResponse.json();

        if (!precheckResponse.ok || !precheckData.available) {
          throw new Error(precheckData.reason || "OpenAI service temporarily unavailable");
        }

        console.log("[AUTO-GEN] âœ… OpenAI service available");

        // Call generation API
        const response = await fetch("/api/generate-image", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            imageUrl: nft.thumbnailUrl || nft.imageUrl,
            tokenId: nft.tokenId,
            name: `Warplet #${nft.tokenId}`,
          }),
        });

        const data = await response.json();

        if (!data.success || !data.imageData) {
          throw new Error(data.error || "Generation failed");
        }

        // Save to Supabase
        const saved = await saveGeneration(fid, data.imageData);
        if (!saved) {
          console.warn("Failed to save generation to Supabase");
        }

        // Update state
        setGeneratedImage(data.imageData);
        setHasAutoGenerated(true);
        console.log("[AUTO-GEN] Auto-generation completed successfully");
      } catch (error) {
        console.error("Auto-generation failed:", error);
        toast.error("Failed to generate Geoplet");
      } finally {
        setIsGenerating(false);
      }
    };

    // Small delay to show Warplet first
    const timer = setTimeout(() => {
      autoGenerate();
    }, 5000);

    return () => clearTimeout(timer);
  }, [address, nft, fid, hasAutoGenerated, isGenerating, saveGeneration]);

  // Share handlers
  const handleFarcasterShare = async () => {
    if (!generatedImage || !nft) return;
    try {
      await shareToFarcaster(generatedImage, nft.tokenId, nft.name);
    } catch (error) {
      console.error("Failed to share:", error);
      toast.error("Failed to share to Farcaster");
    }
  };

  const handleXShare = () => {
    const text = "Check out my Geoplet! ðŸŽ¨";
    const url = `https://geoplet.geoart.studio`;
    const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(
      text
    )}&url=${encodeURIComponent(url)}`;
    window.open(twitterUrl, "_blank");
  };

  return (
    <>
      {/* Top Section */}
      <TopSection
        onFarcasterShare={generatedImage ? handleFarcasterShare : undefined}
        onXShare={generatedImage ? handleXShare : undefined}
      />

      {/* Main Content */}
      <main className="flex-1 flex flex-col gap-8 px-4 pb-20">
        {/* Hero Section */}
        <div className="mt-4">
          <HeroSection
            warpletImage={nft?.thumbnailUrl || nft?.imageUrl || null}
            warpletTokenId={nft?.tokenId || null}
            generatedImage={generatedImage}
            isGenerating={isGenerating}
            isMinted={isMinted}
          />
        </div>

        {/* Split Buttons: Regenerate & Mint */}
        <div className="flex flex-col gap-4 justify-center items-center">
          <RegenerateButton
            disabled={!hasAutoGenerated}
            onRegenerate={(imageData) => {
              setGeneratedImage(imageData);
            }}
            onSaveToSupabase={async (imageData) => {
              if (!fid) return false;
              return await saveGeneration(fid, imageData);
            }}
          />
          <MintButton
            disabled={!generatedImage}
            generatedImage={generatedImage}
            onSuccess={(hash, tokenId) => {
              setMintTxHash(hash);
              setMintedTokenId(tokenId);
              setShowSuccessModal(true);
            }}
            onDeleteFromSupabase={async () => {
              if (!fid) return false;
              return await deleteGeneration(fid);
            }}
          />
        </div>
      </main>

      {/* Success Modal */}
      <SuccessModal
        isOpen={showSuccessModal}
        onClose={() => {
          setShowSuccessModal(false);
          setGeneratedImage(null);
        }}
        image={generatedImage}
        txHash={mintTxHash}
        tokenId={mintedTokenId}
      />
    </>
  );
}
