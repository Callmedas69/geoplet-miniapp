import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { toFile } from 'openai/uploads';
import sharp from 'sharp';
import { checkOpenAIAvailability } from '@/lib/openai-health';
import { supabaseAdmin } from '@/lib/supabase';

// CORS headers
const corsHeaders = {
  'Access-Control-Allow-Origin': process.env.NEXT_PUBLIC_APP_URL || 'https://geoplet.geoart.studio',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, X-Payment',
};

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

/**
 * Conditional logging wrapper - only logs in development
 */
const log = (...args: unknown[]) => {
  if (process.env.NODE_ENV !== 'production') {
    console.log(...args);
  }
};

/**
 * Generate geometric art using gpt-image-1 with direct image-to-image transformation
 */
async function generateGeometricArt(
  imageUrl: string,
  tokenId: string,
  name: string,
  retryCount = 0
): Promise<{ imageData: string; prompt: string }> {
  try {
    log(`\nüé® Generating geometric art for ${name} (Token #${tokenId})`);
    log(`üì∑ Image URL: ${imageUrl}`);

    // Whitelist allowed image domains (SSRF prevention)
    const ALLOWED_DOMAINS = [
      'base-mainnet.g.alchemy.com',
      'nft-cdn.alchemy.com',
      'ipfs.io',
      'gateway.pinata.cloud',
      'res.cloudinary.com',        // Cloudinary CDN (Warpcast/Farcaster images)
      'imagedelivery.net',          // Cloudflare Images (Warpcast/Farcaster images)
      `ipfs.raribleuserdata.com`,
    ];

    const url = new URL(imageUrl);
    const isAllowed = ALLOWED_DOMAINS.some(domain => url.hostname.includes(domain));

    if (!isAllowed) {
      throw new Error(`Invalid image URL domain: ${url.hostname}. Only whitelisted CDN domains allowed (Alchemy, IPFS, Cloudinary, Cloudflare).`);
    }

    // Fetch the original Warplet image
    log(`üì• Fetching image from URL...`);
    const imageResponse = await fetch(imageUrl);
    if (!imageResponse.ok) {
      throw new Error(`Failed to fetch image: ${imageResponse.statusText}`);
    }

    const imageBlob = await imageResponse.blob();
    const imageBuffer = await imageBlob.arrayBuffer();

    // Convert to File object for OpenAI API
    const imageFile = await toFile(Buffer.from(imageBuffer), 'warplet.png', { type: 'image/png' });

    log(`üé® Generating geometric interpretation with gpt-image-1...`);

    const prompt = `Transform this image into bauhaus and suprematism geometric art style with these strict rules:
    - Add random monsters attributes for halloween party
    - Use solid flat colors with subtle shading between shapes to create 3D depth
    - Use clean sharp edges and straight lines
    - Keep the character's exact pose as shown in reference image
    - Keep the character's exact body shape as shown in reference image
    - Plain solid pastel color background with more empty space around the smaller character`;


    log(`üìù Prompt: ${prompt}`);

    // Use images.edit() with gpt-image-1 for direct image-to-image transformation
    // Note: images.generate() with referenced_image does NOT exist in OpenAI SDK
    // input_fidelity: 'high' makes the model preserve pose/features more consistently
    const response = await openai.images.edit({
      model: 'gpt-image-1',
      image: imageFile,
      prompt: prompt,
      n: 1,
      size: '1024x1024',
      input_fidelity: 'high',
    });

    log(`üîç API Response received`);

    if (!response.data || response.data.length === 0) {
      console.error('‚ùå No data in response');
      throw new Error('No image generated by gpt-image-1');
    }

    // gpt-image-1 always returns base64-encoded images (b64_json), not URLs
    const b64Json = response.data[0]?.b64_json;

    if (!b64Json) {
      // Retry logic: if no data and haven't retried yet, try once more
      if (retryCount < 1) {
        console.warn(`‚ö†Ô∏è Empty response from gpt-image-1, retrying... (attempt ${retryCount + 1}/1)`);
        return await generateGeometricArt(imageUrl, tokenId, name, retryCount + 1);
      }
      console.error('‚ùå No b64_json in data after retry');
      throw new Error('No image data returned by gpt-image-1');
    }

    log(`‚úÖ Received base64 image (${(b64Json.length / 1024).toFixed(2)} KB)`);

    // Compress image for on-chain storage (reduce payload size for minting)
    // Contract limit: 24KB (24576 bytes), target: <20KB for safety margin
    log(`üóúÔ∏è Compressing image for on-chain storage...`);
    const generatedImageBuffer = Buffer.from(b64Json, 'base64');

    // Adaptive compression: try progressively lower quality until size < 20KB
    const TARGET_SIZE = 20 * 1024; // 20KB target (leaves 4KB buffer)
    const MAX_SIZE = 24 * 1024; // 24KB absolute limit
    const compressionAttempts = [
      { quality: 70, effort: 6 },  // First attempt: slightly more aggressive
      { quality: 60, effort: 6 },  // Second attempt: more compression
      { quality: 50, effort: 6 },  // Third attempt: high compression
      { quality: 40, effort: 6 },  // Fourth attempt: very high compression
    ];

    let compressed: Buffer | null = null;
    let finalQuality = 70;

    for (const { quality, effort } of compressionAttempts) {
      compressed = await sharp(generatedImageBuffer)
        .resize(512, 512, { fit: 'contain', background: { r: 0, g: 0, b: 0, alpha: 0 } })
        .webp({ quality, effort })
        .toBuffer();

      const sizeInBytes = compressed.length;
      const sizeInKB = (sizeInBytes / 1024).toFixed(2);

      log(`üîç Compression attempt (quality ${quality}): ${sizeInKB} KB`);

      if (sizeInBytes <= TARGET_SIZE) {
        finalQuality = quality;
        log(`‚úÖ Target size achieved with quality ${quality}: ${sizeInKB} KB`);
        break;
      } else if (sizeInBytes <= MAX_SIZE) {
        // Within limit but not ideal - continue trying for better compression
        finalQuality = quality;
        log(`‚ö†Ô∏è  Size ${sizeInKB} KB acceptable but trying lower quality...`);
      }
    }

    if (!compressed) {
      throw new Error('Compression failed - no buffer generated');
    }

    const compressedBase64 = compressed.toString('base64');
    const finalSizeKB = (compressed.length / 1024).toFixed(2);

    if (compressed.length > MAX_SIZE) {
      log(`‚ùå Image still too large after all compression attempts: ${finalSizeKB} KB`);
      throw new Error(`Image too large even after aggressive compression: ${finalSizeKB} KB. Maximum is 24 KB.`);
    }

    const base64Data = compressedBase64;

    log(`‚úÖ Compression complete! Original: ${(b64Json.length / 1024).toFixed(2)} KB ‚Üí Compressed: ${finalSizeKB} KB (quality: ${finalQuality})`);
    log(`‚úÖ Size reduction: ${(((b64Json.length - compressed.length) / b64Json.length) * 100).toFixed(1)}%\n`);

    return { imageData: base64Data, prompt };
  } catch (error: unknown) {
    console.error('‚ùå Generation failed:', error);
    const errorMessage = error instanceof Error ? error.message : 'Image generation failed';
    throw new Error(errorMessage);
  }
}

// Handle OPTIONS preflight
export async function OPTIONS() {
  return NextResponse.json({}, { headers: corsHeaders });
}

/**
 * POST /api/generate-image
 * Generate geometric art from Warplet NFT
 * - FREE for first-time generation (auto-gen)
 * - $0.90 USDC for regeneration (x402 payment required)
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { imageUrl, tokenId, name, fid } = body;

    // Validation
    if (!imageUrl || !tokenId) {
      return NextResponse.json(
        { error: 'Missing required fields: imageUrl, tokenId' },
        { status: 400, headers: corsHeaders }
      );
    }

    // Validate image URL format
    if (!imageUrl.startsWith('http://') && !imageUrl.startsWith('https://')) {
      return NextResponse.json(
        { error: 'Invalid image URL format' },
        { status: 400, headers: corsHeaders }
      );
    }

    console.log(`[AUTO-GEN] Free generation for FID: ${fid || 'unknown'}`);

    // Pre-check OpenAI availability
    console.log('[OPENAI-PRECHECK] Checking service availability...');
    const health = await checkOpenAIAvailability();

    if (!health.available) {
      console.error('[OPENAI-PRECHECK] ‚ùå Service unavailable:', health.reason);
      return NextResponse.json(
        {
          error: health.reason || 'OpenAI service temporarily unavailable',
          success: false,
          code: 'OPENAI_UNAVAILABLE',
        },
        {
          status: 503,
          headers: corsHeaders,
        }
      );
    }

    console.log('[OPENAI-PRECHECK] ‚úÖ Service available');

    log(`\nüé® Starting generation for Warplet #${tokenId}`);
    log(`üì∑ Image URL: ${imageUrl}`);
    log(`üí∞ Payment: FREE (always free generation)`);

    // Generate geometric art
    const result = await generateGeometricArt(imageUrl, tokenId, name || `Warplet #${tokenId}`);

    log(`‚úÖ Generation successful for Warplet #${tokenId}\n`);

    return NextResponse.json(
      {
        success: true,
        imageData: result.imageData, // Base64 for download and future onchain storage
        metadata: {
          tokenId,
          name: name || `Warplet #${tokenId}`,
          model: 'gpt-image-1',
          prompt: result.prompt,
          size: '512x512',
          timestamp: new Date().toISOString(),
        },
      },
      {
        status: 200,
        headers: {
          ...corsHeaders,
          'Access-Control-Expose-Headers': 'X-PAYMENT-RESPONSE',
        },
      }
    );
  } catch (error: unknown) {
    console.error('‚ùå API Error:', error);

    const errorMessage = error instanceof Error ? error.message : 'Image generation failed';

    return NextResponse.json(
      {
        error: errorMessage,
        success: false,
      },
      { status: 500, headers: corsHeaders }
    );
  }
}

/**
 * GET /api/generate-image
 * Health check
 */
export async function GET() {
  return NextResponse.json({
    status: 'ok',
    service: 'geometric-art-generation',
    price: 'FREE (always free)',
    network: 'base',
    provider: 'OpenAI gpt-image-1',
    paymentProtocol: 'none',
  });
}
