import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { toFile } from 'openai/uploads';
import sharp from 'sharp';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

/**
 * Conditional logging wrapper - only logs in development
 */
const log = (...args: unknown[]) => {
  if (process.env.NODE_ENV !== 'production') {
    console.log(...args);
  }
};

/**
 * Generate geometric art using gpt-image-1 with direct image-to-image transformation
 */
async function generateGeometricArt(
  imageUrl: string,
  tokenId: string,
  name: string,
  retryCount = 0
): Promise<{ imageData: string; prompt: string }> {
  try {
    log(`\nüé® Generating geometric art for ${name} (Token #${tokenId})`);
    log(`üì∑ Image URL: ${imageUrl}`);

    // Fetch the original Warplet image
    log(`üì• Fetching image from URL...`);
    const imageResponse = await fetch(imageUrl);
    if (!imageResponse.ok) {
      throw new Error(`Failed to fetch image: ${imageResponse.statusText}`);
    }

    const imageBlob = await imageResponse.blob();
    const imageBuffer = await imageBlob.arrayBuffer();

    // Convert to File object for OpenAI API
    const imageFile = await toFile(Buffer.from(imageBuffer), 'warplet.png', { type: 'image/png' });

    log(`üé® Generating geometric interpretation with gpt-image-1...`);

    const prompt = `Transform this image into bauhaus and suprematism geometric art style with these strict rules:
    - Add random monsters attributes for halloween party
    - Use solid flat colors with subtle shading between shapes to create 3D depth
    - Use clean sharp edges and straight lines
    - Keep the character's exact pose as shown in reference image
    - Keep the character's exact body shape as shown in reference image
    - Plain solid pastel color background with more empty space around the smaller character`;


    log(`üìù Prompt: ${prompt}`);

    // Use images.edit() with gpt-image-1 for direct image-to-image transformation
    // Note: images.generate() with referenced_image does NOT exist in OpenAI SDK
    // input_fidelity: 'high' makes the model preserve pose/features more consistently
    const response = await openai.images.edit({
      model: 'gpt-image-1',
      image: imageFile,
      prompt: prompt,
      n: 1,
      size: '1024x1024',
      input_fidelity: 'high',
    });

    log(`üîç API Response received`);

    if (!response.data || response.data.length === 0) {
      console.error('‚ùå No data in response');
      throw new Error('No image generated by gpt-image-1');
    }

    // gpt-image-1 always returns base64-encoded images (b64_json), not URLs
    const b64Json = response.data[0]?.b64_json;

    if (!b64Json) {
      // Retry logic: if no data and haven't retried yet, try once more
      if (retryCount < 1) {
        console.warn(`‚ö†Ô∏è Empty response from gpt-image-1, retrying... (attempt ${retryCount + 1}/1)`);
        return await generateGeometricArt(imageUrl, tokenId, name, retryCount + 1);
      }
      console.error('‚ùå No b64_json in data after retry');
      throw new Error('No image data returned by gpt-image-1');
    }

    log(`‚úÖ Received base64 image (${(b64Json.length / 1024).toFixed(2)} KB)`);

    // Compress image for on-chain storage (reduce payload size for minting)
    log(`üóúÔ∏è Compressing image for on-chain storage...`);
    const generatedImageBuffer = Buffer.from(b64Json, 'base64');
    const compressed = await sharp(generatedImageBuffer)
      .resize(512, 512, { fit: 'contain', background: { r: 0, g: 0, b: 0, alpha: 0 } })
      .webp({ quality: 85, effort: 6 })
      .toBuffer();

    const compressedBase64 = compressed.toString('base64');
    const base64Data = `data:image/webp;base64,${compressedBase64}`;

    log(`‚úÖ Compression complete! Original: ${(b64Json.length / 1024).toFixed(2)} KB ‚Üí Compressed: ${(compressedBase64.length / 1024).toFixed(2)} KB`);
    log(`‚úÖ Size reduction: ${(((b64Json.length - compressedBase64.length) / b64Json.length) * 100).toFixed(1)}%\n`);

    return { imageData: base64Data, prompt };
  } catch (error: unknown) {
    console.error('‚ùå Generation failed:', error);
    const errorMessage = error instanceof Error ? error.message : 'Image generation failed';
    throw new Error(errorMessage);
  }
}

/**
 * POST /api/generate-image
 * Generate geometric art from Warplet NFT (FREE)
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { imageUrl, tokenId, name } = body;

    // Validation
    if (!imageUrl || !tokenId) {
      return NextResponse.json(
        { error: 'Missing required fields: imageUrl, tokenId' },
        { status: 400 }
      );
    }

    // Validate image URL format
    if (!imageUrl.startsWith('http://') && !imageUrl.startsWith('https://')) {
      return NextResponse.json(
        { error: 'Invalid image URL format' },
        { status: 400 }
      );
    }

    log(`\nüé® Starting generation for Warplet #${tokenId}`);
    log(`üì∑ Image URL: ${imageUrl}`);

    // Generate geometric art (FREE - no payment required)
    const result = await generateGeometricArt(imageUrl, tokenId, name || `Warplet #${tokenId}`);

    log(`‚úÖ Generation successful for Warplet #${tokenId}\n`);

    return NextResponse.json({
      success: true,
      imageData: result.imageData, // Base64 for download and future onchain storage
      metadata: {
        tokenId,
        name: name || `Warplet #${tokenId}`,
        model: 'gpt-image-1',
        prompt: result.prompt,
        size: '1024x1024',
        timestamp: new Date().toISOString(),
      },
    });
  } catch (error: unknown) {
    console.error('‚ùå API Error:', error);

    const errorMessage = error instanceof Error ? error.message : 'Image generation failed';

    return NextResponse.json(
      {
        error: errorMessage,
        success: false,
      },
      { status: 500 }
    );
  }
}

/**
 * GET /api/generate-image
 * Health check
 */
export async function GET() {
  return NextResponse.json({
    status: 'ok',
    service: 'geometric-art-generation',
    price: 'FREE (testing)',
    network: 'base',
    provider: 'OpenAI gpt-image-1',
  });
}
